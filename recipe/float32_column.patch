diff --git a/src/ihm_format.c b/src/ihm_format.c
index 89df54f..fbc5717 100644
--- a/src/ihm_format.c
+++ b/src/ihm_format.c
@@ -2558,6 +2558,7 @@ static bool process_column_data(struct bcif_column *col,
   if (!decode_bcif_data(&col->data, col->first_encoding, err)) return false;
   if (col->data.type != BCIF_DATA_INT32
       && col->data.type != BCIF_DATA_UINT8
+      && col->data.type != BCIF_DATA_FLOAT
       && col->data.type != BCIF_DATA_DOUBLE
       && col->data.type != BCIF_DATA_STRING) {
     ihm_error_set(err, IHM_ERROR_FILE_FORMAT,
@@ -2716,6 +2717,10 @@ static void set_value_from_data(struct ihm_reader *reader,
   case BCIF_DATA_STRING:
     set_value_from_bcif_string(key, data->data.string[irow], err);
     break;
+  case BCIF_DATA_FLOAT:
+    /* promote to double */
+    set_value_from_bcif_double(key, data->data.float32[irow], buffer);
+    break;
   case BCIF_DATA_DOUBLE:
     set_value_from_bcif_double(key, data->data.float64[irow], buffer);
     break;
diff --git a/test/test_format_bcif.py b/test/test_format_bcif.py
index e0c1803..dc29373 100644
--- a/test/test_format_bcif.py
+++ b/test/test_format_bcif.py
@@ -319,9 +319,15 @@ class Tests(unittest.TestCase):
         self.assertIsInstance(data[0], str)
         self.assertAlmostEqual(float(data[0]), 42.0, delta=0.1)
 
-        # unsupported type
+        # type 32 (32-bit float)
+        data = get_decoded(ihm.format_bcif._Float32, b'\x00\x00(B')
+        self.assertIsInstance(data[0], str)
+        self.assertAlmostEqual(float(data[0]), 42.0, delta=0.1)
+
+        # unsupported type (16-bit int)
         self.assertRaises(_format.FileFormatError,
-                          get_decoded, ihm.format_bcif._Float32, b'\x00\x00(B')
+                          get_decoded, ihm.format_bcif._Int16,
+                          struct.pack('<h', 5))
 
     def test_integer_packing_decoder_signed(self):
         """Test IntegerPacking decoder with signed data"""
